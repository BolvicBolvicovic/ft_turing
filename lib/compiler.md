# Language Definition

Definition of the "assembly" language for a Turing machine that compiles to the requiered JSON format for ft_turing.
Note that the project is using the version of the compiler for OCaml 5.3.

<details>
  <summary>Table of Contents</summary>
  <ol>
        <li>
            <a href="#the-turing-machine">The Turing machine</a>
            <ul>
                <li><a href="#fonctionnement-and-restrictions">Fonctionnement and restrictions</a></li>
                <li><a href="#the-json-format">The JSON format</a></li>
            </ul>
        </li>
        <li>
            <a href="#language-specifics">Language specifics</a>
            <ul>
                <li><a href="#initial-state-and-parameters">Initial State and Parameters</a></li>
                <li><a href="#functions">Functions</a></li>
                <li><a href="#registers">Registers</a></li>
                <li>
                    <a href="#keywords">Keywords</a>
                    <ul>
                        <a href="#self">self</a>
                        <a href="#assignment-then...-and...-">Assignment then... and...</a>
                        <a href="#call-and-other-keywords-for-function-call">call</a>
                    </ul>
                </li>
                <li><a href="#comments">Comments</a></li>
            </ul>
        </li>
  </ol>
</details>

## The Turing Machine

ft_turing is able to simulate a single headed and single tape Turing machine from a json machine description given as a parameter to your program.
The json machine description is sligthly simplier than a formal description of the same machine.

### Fonctionnement and Restrictions

Because the Turing machine that is simulated by the ft_turing program is a single headed and single tape machine,
it means that each transition (that are just function calls):
- takes in one parameter (the character under the head)
- can overwrite that parameter
- moves the head (LEFT or RIGHT)
- call a new state (that is alike a function) that takes in the next character read after the movement.

These two last actions are decided by the function that is called and its parameter.
They are the building blocks for all the programing you want to do AND are the building block of this assembly language.

### The JSON Format

The json fields are defined as follows:
- name: The name of the described machine
- alphabet: Both input and work alphabet of the machine merged into a single alphabet
for simplicity’s sake, including the blank character. Each character of the alphabet
must be a string of length strictly equal to 1.
blank: The blank character, must be part of the alphabet, must NOT be part of the
input.
- states: The exhaustive list of the machine’s states names.
- initial: The initial state of the machine, must be part of the states list.
- finals: The exhaustive list of the machine’s final states. This list must be a sub-list of the states list.
- transitions: A dictionnary of the machine’s transitions indexed by state name.
Each transition is a list of dictionnaries, and each dictionnary describes the transition for
a given character under the head of the machine. A transition is defined as follows:
1. read: The character of the machine’s alphabet on the tape under the machine’s head.
2. to_state: The new state of the machine after the transition is done.
3. write: The character of the machine’s alphabet to write on the tape before moving the head.
4. action: Movement of the head for this transition, either LEFT, or RIGHT.

You can direcly write your program in JSON but for bigger programs like a Universal Turing Machine (UTM), you will notice that it is limited.
The purpose of this assembly language is to ease the writing of any program that can be run by ft_turing.

<p align="right">(<a href="#language-definition">back to top</a>)</p>

## Language Specifics

Here is you will find all the tools that are given by the language.

### Initial State and Parameters

Every program you write has to start with an alphabet. Every alphabet starts with its blank character.
You can define an alphabet as follow:
```asm
alphabet[012]
```
Every program you write has to contain an initial state that will act as the entry point of your program.
You can define this entry point with the _start function as follow:
```asm
_start:
    [0]     <- self then RIGHT and bar
    [12]    <- 0    then LEFT  and foo
# Notice that I use white spaces to write a line of code in a function block.
# Note that you cannot define a function inside another function.
# Last but not least, you cannot have more than one level of indentation
```

### Functions

Functions are defined in the same way _start is except they can have any name you want. They have to contain at least one line of code.
You don't have to write a special line an incorrect input, it is automatically generated by the compiler.
Example of function
```asm
foo:
    [0]     <- self then RIGHT and bar
#    ^      ^   ^    ^     ^    ^   ^
#    1      2   3    4     5    6   7
```
1. This is an array of all possible input for this specific output.
2. The operator "<-" is the assignment operator.
3. The value that is assigned to the input.
4. "then" keyword. Just a convenient way of describing what is happening. Acts as a separator.
5. Action of the head before next function call. Can be either "LEFT", "RIGHT" or "STILL" (avoid using "STILL" since it significantly increases the time complexity of your program).
6. "and" keyword. Just like "then", acts as a separator.
7. Function call with the name of the callee.

### Registers

There are 5 registers of 32 bits encoded in hexadecimal: eax, ebx, ecx, edx.
You can use a subroutine to read/write them.
Avoid to use them since it will significantly increase the time complexity of your program.

### Keywords

#### self

The "self" keyword is a substitution of the input character. It is necessary for a line that matches on different inputs.
Can also be used to modify / compare with a register.

#### assignment then... and...

As described <a href="#functions">previously</a> keywords "then" and "and" are a convenient way to write a line of code.
Though, this syntax is mandatory for most lines of codes. See next section for special cases.

#### Keywords that interacts with a memory tape.

Using these keywords has huge overhead. The reason is that it has to interact with another tape (the memory tape).
Since we need to simulate this other tape, this operation is increasing the amount of actions that have to be done by a lot.

##### mov

The "mov" keyword takes two parameter: the register that is to be modified and the value that is to be stored.
Example:
```asm
foo:
    [1]     <- 0    mov eax self then LEFT and bar
    [0]     <- self then RIGHT and bar
```
Essentialy, a subroutine is generated to write on a the memory tape and then comes back to were we stoped

##### eq, true and false

The "eq" keyword takes two parameter: the register that contains a value previously stored and the value that is to be compared with.
It returns a boolean ("true" or "false") on which we can take action
Example:
```asm
foo:
    [1]     <- 0    eq eax self : true then LEFT and bar else RIGHT and foo
    [0]     <- self then RIGHT and bar
```
As for mov, a subroutine is generated to compare with the input value.

### Comments
Comments are defined by the character '#'.
For example:
```asm
# This a one line comment.
```
If you want to write multiline comments then use the comment character at the start of each line.
```asm
# This
# is
# a multiline
# comment
```

<p align="right">(<a href="#language-definition">back to top</a>)</p>
